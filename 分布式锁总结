#缺陷：
  ##redis:Redis Cluster，或者是redis master-slave架构的主从异步复制导致的Redis分布式锁的最大缺陷：在Redis Master实例宕机的时候，可能导致多个客户端同时完成加锁。
  ##zoopkeeper:如果client端没有宕机，由于网络原因导致Zookeeper服务与client心跳失败，那么Zookeeper也会把临时数据给删除掉的，这时如果client还在操作共享数据，是有一定风险的。




分布式锁的设计与实现中，我们可以看出每种实现都有各自的特点，针对潜在的问题有不同的解决方案，归纳如下：



#性能：Redis > Zookeeper > DB。

避免死锁：DB通过应用层设置定时任务来删除过期还未释放的锁，Redis通过设置超时时间来解决，而Zookeeper是通过临时节点来解决。

可用性：DB可通过数据库同步复制，vip切换master来解决；Redis可通过集群或者master-slave方式来解决；Zookeeper本身自己是通过zab协议集群部署来解决的。注意，DB和Redis的复制一般都是异步的，也就是说某些时刻分布式锁发生故障可能存在数据不一致问题，而Zookeeper本身通过zab协议保证集群内(至少n/2+1个)节点数据一致性。

锁唤醒：DB和Redis分布式锁一般不支持唤醒机制（也可以通过应用层自己做轮询检测锁是否空闲，空闲就唤醒内部加锁线程），Zookeeper可通过本身的watcher/notify机制来做。



使用分布式锁，安全性上和多线程（同一个进程内）加锁是没法比的，可能由于网络原因，分布式锁服务（因为超时或者认为client挂了）将加锁资源给删除了，如果client端继续操作共享资源，此时是有隐患的。



因此，对于分布式锁，一个是要尽量提高分布式锁服务的可用性，另一个就是要部署同一内网，尽量降低网络问题发生几率。



这样来看，貌似分布式锁服务不是“完美”的（PS：技术貌似也不好做到十全十美 :( ），那么开发人员该如何选择分布式锁呢？最好是结合自己的业务实际场景，来选择不同的分布式锁实现，一般来说，基于Redis的分布式锁服务应用较多。
